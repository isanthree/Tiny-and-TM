/*
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输
入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，
则重建二叉树并返回。
*/
TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		 TreeNode* root=(TreeNode*)malloc(sizeof(TreeNode));
		 /*递归，函数返回根节点，或者是NULL*/
		 if (pre.size() == 0||vin.size()==0)
			 return NULL;
		 root->val = pre[0];
		 //计算左右子树的pre,vin
		 vector<int> lpre, lvin;
		 vector<int> rpre, rvin;
		 vector<int>::iterator result = find(vin.begin(), vin.end(), pre[0]); //在中序遍历中找到左子树
		 lvin = vector<int>(vin.begin(), result);
		 rvin = vector<int>(result + 1, vin.end());
		 lpre = vector<int>(pre.begin() + 1, pre.begin() + 1 + lvin.size());
		 rpre = vector<int>(pre.begin() + 1 + lvin.size(), pre.end());
		 root->left = reConstructBinaryTree(lpre, lvin);
		 root->right = reConstructBinaryTree(rpre, rvin);
		 return root;
	 }
